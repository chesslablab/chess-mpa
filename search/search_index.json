{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"ChesslaBlab Website More detailed documentation will be available soon. Stay tuned!","title":"Home"},{"location":"#chesslablab-website","text":"More detailed documentation will be available soon. Stay tuned!","title":"ChesslaBlab Website"},{"location":"ssl-certificate-setup/","text":"SSL Certificate Setup Some familiarity with Public Key Infrastructure (PKI) is recommended in order to follow this section. The first thing you need to understand about setting up a ChesslaBlab website is that you have to create an SSL certificate to secure four different domain names at once. chesslablab.org www.chesslablab.org api.chesslablab.org async.chesslablab.org The first two, chesslablab.org and www.chesslablab.org , will point to the web server in the chesslablab/website repo. As its name implies, the api.chesslablab.org domain name will point to the REST-like API in the chesslablab/chess-api repo, and async.chesslablab.org to the asynchronous chess server in the chesslablab/chess-server repo. Before the Certificate Authority (CA) can issue the SSL certificate, they need to verify that the Certificate Signing Request (CSR) requester can receive the certificate. This is typically achieved through one of the following methods. Email Validation \u2014 a validation email is sent to the certificate requester. HTTP Validation \u2014 the certificate requester is asked to upload a validation file at their host. DNS Validation \u2014 the certificate requester sets up a CNAME record in the domain's DNS zone for further validation. In this example, it is assumed that Certbot is run to automatically get a free HTTPS certificate. The ChesslaBlab website is running on an Ubuntu server and the certificate is validated using DNS validation as it is described next. sudo certbot certonly --standalone Saving debug log to /var/log/letsencrypt/letsencrypt.log Please enter the domain name(s) you would like on your certificate (comma and/or space separated) (Enter 'c' to cancel): chesslablab.org www.chesslablab.org api.chesslablab.org async.chesslablab.org Requesting a certificate for chesslablab.org and 3 more domains Successfully received certificate. Certificate is saved at: /etc/letsencrypt/live/chesslablab.org-0001/fullchain.pem Key is saved at: /etc/letsencrypt/live/chesslablab.org-0001/privkey.pem This certificate expires on 2024-04-23. These files will be updated when the certificate renews. Certbot has set up a scheduled task to automatically renew this certificate in the background. - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - If you like Certbot, please consider supporting our work by: * Donating to ISRG / Let's Encrypt: https://letsencrypt.org/donate * Donating to EFF: https://eff.org/donate-le - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - The command above generated two files, fullchain.pem and privkey.pem , that then were installed in the repos mentioned above: chesslablab/website chesslablab/chess-api chesslablab/chess-server It is worth saying that for this to function properly, Certbot's documentation recommends to have a working web site that can already be accessed using HTTP on port 80. Self-Signed Wildcard SSL Certificate with OpenSSL If issuing a wildcard certificate with DNS validation sounds too complicated to you, OpenSSL might be an alternate solution for the development environment. You may want to create a self-signed multi-domain SSL certificate using OpenSSL. openssl genrsa -aes256 -passout pass:foobar -out chesslablab.org.pem 2048 openssl req -passin pass:foobar -new -sha256 -key chesslablab.org.pem -subj \"/C=US/ST=CA/O=ChesslaBlab, Inc./CN=chesslablab.org\" -reqexts SAN -config <(cat /etc/ssl/openssl.cnf <(printf \"[SAN]\\nsubjectAltName=DNS:*.mydomain.org\")) -out chesslablab.org.csr openssl x509 -passin pass:foobar -req -days 365 -in chesslablab.org.csr -signkey chesslablab.org.pem -out chesslablab.org.crt openssl rsa -passin pass:foobar -in chesslablab.org.pem -out chesslablab.org.key The command above will generate four files: chesslablab.org.crt chesslablab.org.csr chesslablab.org.key chesslablab.org.pem Then, chesslablab.org.crt and chesslablab.org.key must be renamed in order to match both the certificate and the key filename created by Certbot. As noted before, it is assumed that Certbot is used to automatically generate the HTTPS certificate so all repositories are configured to read these two files on startup. mv chesslablab.org.crt fullchain.pem mv chesslablab.org.key privkey.pem With the pieces of the puzzle in place, which is to say, the web server, the REST-like API and the asynchronous chess server, it is of vital importance to add the chess server's self-signed certificate as trusted to your browser. Figure 1 . Make the browser trust the chess server's self-signed certificate. If skipping this step, the web browser won't be able to connect to the chess server. The latter will complain with an SSL handshake error. SSL handshake error: stream_socket_enable_crypto(): SSL operation failed with code 1. OpenSSL Error messages: error:14094416:SSL routines:ssl3_read_bytes:sslv3 alert certificate unknown And the web browser will throw an error accordingly. WebSocket connection to 'wss://async.chesslablab.org:8443/' failed Figure 2 . WebSocket connection to 'wss://async.chesslablab.org:8443/' failed. The exact same thing goes for the REST-like API: Its self-signed certificate needs to be added as trusted to your browser. Figure 3 . Make the browser trust the API's self-signed certificate. If skipping this step, the web browser won't be able to connect to the chess API. The latter will complain with an ERR_CERT_AUTHORITY_INVALID error. GET https://api.chesslablab.org/v1/annotations/games net::ERR_CERT_AUTHORITY_INVALID Figure 4 . The browser doesn't recognize the API's certificate. Conclusion In order to run a ChesslaBlab website, a wildcard SSL certificate needs to be issued and installed in the following repos: chesslablab/website chesslablab/chess-api chesslablab/chess-server Certbot is run to automatically get a free HTTPS certificate using DNS validation. If issuing a wildcard certificate with DNS validation sounds too complicated to you, OpenSSL might be an alternate solution for the development environment.","title":"SSL Certificate Setup"},{"location":"ssl-certificate-setup/#ssl-certificate-setup","text":"Some familiarity with Public Key Infrastructure (PKI) is recommended in order to follow this section. The first thing you need to understand about setting up a ChesslaBlab website is that you have to create an SSL certificate to secure four different domain names at once. chesslablab.org www.chesslablab.org api.chesslablab.org async.chesslablab.org The first two, chesslablab.org and www.chesslablab.org , will point to the web server in the chesslablab/website repo. As its name implies, the api.chesslablab.org domain name will point to the REST-like API in the chesslablab/chess-api repo, and async.chesslablab.org to the asynchronous chess server in the chesslablab/chess-server repo. Before the Certificate Authority (CA) can issue the SSL certificate, they need to verify that the Certificate Signing Request (CSR) requester can receive the certificate. This is typically achieved through one of the following methods. Email Validation \u2014 a validation email is sent to the certificate requester. HTTP Validation \u2014 the certificate requester is asked to upload a validation file at their host. DNS Validation \u2014 the certificate requester sets up a CNAME record in the domain's DNS zone for further validation. In this example, it is assumed that Certbot is run to automatically get a free HTTPS certificate. The ChesslaBlab website is running on an Ubuntu server and the certificate is validated using DNS validation as it is described next. sudo certbot certonly --standalone Saving debug log to /var/log/letsencrypt/letsencrypt.log Please enter the domain name(s) you would like on your certificate (comma and/or space separated) (Enter 'c' to cancel): chesslablab.org www.chesslablab.org api.chesslablab.org async.chesslablab.org Requesting a certificate for chesslablab.org and 3 more domains Successfully received certificate. Certificate is saved at: /etc/letsencrypt/live/chesslablab.org-0001/fullchain.pem Key is saved at: /etc/letsencrypt/live/chesslablab.org-0001/privkey.pem This certificate expires on 2024-04-23. These files will be updated when the certificate renews. Certbot has set up a scheduled task to automatically renew this certificate in the background. - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - If you like Certbot, please consider supporting our work by: * Donating to ISRG / Let's Encrypt: https://letsencrypt.org/donate * Donating to EFF: https://eff.org/donate-le - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - The command above generated two files, fullchain.pem and privkey.pem , that then were installed in the repos mentioned above: chesslablab/website chesslablab/chess-api chesslablab/chess-server It is worth saying that for this to function properly, Certbot's documentation recommends to have a working web site that can already be accessed using HTTP on port 80.","title":"SSL Certificate Setup"},{"location":"ssl-certificate-setup/#self-signed-wildcard-ssl-certificate-with-openssl","text":"If issuing a wildcard certificate with DNS validation sounds too complicated to you, OpenSSL might be an alternate solution for the development environment. You may want to create a self-signed multi-domain SSL certificate using OpenSSL. openssl genrsa -aes256 -passout pass:foobar -out chesslablab.org.pem 2048 openssl req -passin pass:foobar -new -sha256 -key chesslablab.org.pem -subj \"/C=US/ST=CA/O=ChesslaBlab, Inc./CN=chesslablab.org\" -reqexts SAN -config <(cat /etc/ssl/openssl.cnf <(printf \"[SAN]\\nsubjectAltName=DNS:*.mydomain.org\")) -out chesslablab.org.csr openssl x509 -passin pass:foobar -req -days 365 -in chesslablab.org.csr -signkey chesslablab.org.pem -out chesslablab.org.crt openssl rsa -passin pass:foobar -in chesslablab.org.pem -out chesslablab.org.key The command above will generate four files: chesslablab.org.crt chesslablab.org.csr chesslablab.org.key chesslablab.org.pem Then, chesslablab.org.crt and chesslablab.org.key must be renamed in order to match both the certificate and the key filename created by Certbot. As noted before, it is assumed that Certbot is used to automatically generate the HTTPS certificate so all repositories are configured to read these two files on startup. mv chesslablab.org.crt fullchain.pem mv chesslablab.org.key privkey.pem With the pieces of the puzzle in place, which is to say, the web server, the REST-like API and the asynchronous chess server, it is of vital importance to add the chess server's self-signed certificate as trusted to your browser. Figure 1 . Make the browser trust the chess server's self-signed certificate. If skipping this step, the web browser won't be able to connect to the chess server. The latter will complain with an SSL handshake error. SSL handshake error: stream_socket_enable_crypto(): SSL operation failed with code 1. OpenSSL Error messages: error:14094416:SSL routines:ssl3_read_bytes:sslv3 alert certificate unknown And the web browser will throw an error accordingly. WebSocket connection to 'wss://async.chesslablab.org:8443/' failed Figure 2 . WebSocket connection to 'wss://async.chesslablab.org:8443/' failed. The exact same thing goes for the REST-like API: Its self-signed certificate needs to be added as trusted to your browser. Figure 3 . Make the browser trust the API's self-signed certificate. If skipping this step, the web browser won't be able to connect to the chess API. The latter will complain with an ERR_CERT_AUTHORITY_INVALID error. GET https://api.chesslablab.org/v1/annotations/games net::ERR_CERT_AUTHORITY_INVALID Figure 4 . The browser doesn't recognize the API's certificate.","title":"Self-Signed Wildcard SSL Certificate with OpenSSL"},{"location":"ssl-certificate-setup/#conclusion","text":"In order to run a ChesslaBlab website, a wildcard SSL certificate needs to be issued and installed in the following repos: chesslablab/website chesslablab/chess-api chesslablab/chess-server Certbot is run to automatically get a free HTTPS certificate using DNS validation. If issuing a wildcard certificate with DNS validation sounds too complicated to you, OpenSSL might be an alternate solution for the development environment.","title":"Conclusion"},{"location":"website-architecture/","text":"Website Architecture Some familiarity with JavaScript modules as well as with Symfony's Asset Mapper component is recommended in order to follow this section. The ChesslaBlab website is a multi-page application (MPA) that is not adhering to the MVC architectural pattern. The controller actions are basically sending an HTML document to the browser on each request with the business logic being split between the chess server and the chess API. In this website architecture in particular, there is no model layer (M) and as a result the Controller layer (C) remains quite basic as in the following example. The main reason behind a multi-page architecture like this one as opposed to a single-page architecture is that we want the pages to be indexed by web crawlers. <?php namespace App\\Controller\\Pages\\Play; use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController; use Symfony\\Component\\HttpFoundation\\Response; class ComputerController extends AbstractController { public function index(): Response { return $this->render('pages/play/computer/index.html.twig'); } } As a rule of thumb, there is a .twig.html file and a .js file associated to each controller action. So the structure of the App\\Controller\\Pages namespace is mirroring the structure of both the templates/pages folder and the assets/js/pages folder. src/Controller/Pages/Play/ComputerController.php templates/pages/play/computer/index.html.twig assets/js/pages/play/computer/index.js This naming convention allows developers to reduce memorization because given one file name, the name of the remaining two can be inferred. Each page's JavaScript file is then set up as an entrypoint in the importmap.php config file. The main point of the entrypoint script is to update the DOM on user interaction and data change.","title":"Website Architecture"},{"location":"website-architecture/#website-architecture","text":"Some familiarity with JavaScript modules as well as with Symfony's Asset Mapper component is recommended in order to follow this section. The ChesslaBlab website is a multi-page application (MPA) that is not adhering to the MVC architectural pattern. The controller actions are basically sending an HTML document to the browser on each request with the business logic being split between the chess server and the chess API. In this website architecture in particular, there is no model layer (M) and as a result the Controller layer (C) remains quite basic as in the following example. The main reason behind a multi-page architecture like this one as opposed to a single-page architecture is that we want the pages to be indexed by web crawlers. <?php namespace App\\Controller\\Pages\\Play; use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController; use Symfony\\Component\\HttpFoundation\\Response; class ComputerController extends AbstractController { public function index(): Response { return $this->render('pages/play/computer/index.html.twig'); } } As a rule of thumb, there is a .twig.html file and a .js file associated to each controller action. So the structure of the App\\Controller\\Pages namespace is mirroring the structure of both the templates/pages folder and the assets/js/pages folder. src/Controller/Pages/Play/ComputerController.php templates/pages/play/computer/index.html.twig assets/js/pages/play/computer/index.js This naming convention allows developers to reduce memorization because given one file name, the name of the remaining two can be inferred. Each page's JavaScript file is then set up as an entrypoint in the importmap.php config file. The main point of the entrypoint script is to update the DOM on user interaction and data change.","title":"Website Architecture"}]}