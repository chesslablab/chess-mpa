{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Website Chess developers and business owners can now run their own open-source based platform more easily than ever before because the ChesslaBlab website is super-duper simple to install and set up. To give you an idea of its simplicity, the assets/js folder contains less than 3,000 lines of JavaScript code. cloc assets/js 80 text files. 80 unique files. 0 files ignored. github.com/AlDanial/cloc v 1.90 T=0.05 s (1474.8 files/s, 59028.2 lines/s) ------------------------------------------------------------------------------- Language files blank comment code ------------------------------------------------------------------------------- JavaScript 80 311 33 2858 ------------------------------------------------------------------------------- SUM: 80 311 33 2858 ------------------------------------------------------------------------------- This is made possible with object-oriented programming (OOP) using JavaScript modules . Now you can get rid of libraries and frameworks like React, Vue, Next.js, as well as transpilers, bundlers and so on. Say goodbye to JavaScript fatigue! The ChesslaBlab website is written using OOP and the DOM. The following repositories are required to run an online chess platform with ChesslaBlab: Website PHP Chess Server PHP Chess API Chess Data It is recommended to run the online chess platform using four different servers, one per repository, although everything can be run on the same machine in the development environment.","title":"Home"},{"location":"#website","text":"Chess developers and business owners can now run their own open-source based platform more easily than ever before because the ChesslaBlab website is super-duper simple to install and set up. To give you an idea of its simplicity, the assets/js folder contains less than 3,000 lines of JavaScript code. cloc assets/js 80 text files. 80 unique files. 0 files ignored. github.com/AlDanial/cloc v 1.90 T=0.05 s (1474.8 files/s, 59028.2 lines/s) ------------------------------------------------------------------------------- Language files blank comment code ------------------------------------------------------------------------------- JavaScript 80 311 33 2858 ------------------------------------------------------------------------------- SUM: 80 311 33 2858 ------------------------------------------------------------------------------- This is made possible with object-oriented programming (OOP) using JavaScript modules . Now you can get rid of libraries and frameworks like React, Vue, Next.js, as well as transpilers, bundlers and so on. Say goodbye to JavaScript fatigue! The ChesslaBlab website is written using OOP and the DOM. The following repositories are required to run an online chess platform with ChesslaBlab: Website PHP Chess Server PHP Chess API Chess Data It is recommended to run the online chess platform using four different servers, one per repository, although everything can be run on the same machine in the development environment.","title":"Website"},{"location":"installation/","text":"Installation Setup Clone the chesslablab/website repo into your projects folder. Then cd the website directory and install the Composer dependencies: composer install Set up the browser environment variables: cp assets/env.example.js assets/env.js Clear the cache: php bin/console cache:clear Download the assets: php bin/console importmap:install Compile the assets: php bin/console asset-map:compile Set up file permissions for the var/cache folder: sudo chmod 775 -R var/cache sudo chown $USER:www-data -R var/cache Set up file permissions for the var/log folder: sudo chmod 775 -R var/cache sudo chown $USER:www-data -R var/log Run on a Docker Container First things first, make sure to have created the fullchain.pem and privkey.pem files into the docker/nginx/ssl folder. Development Run the app on port 9443 . docker compose -f docker-compose.dev.yml up -d Production Run the app on port 443 . docker compose -f docker-compose.prod.yml up -d","title":"Installation"},{"location":"installation/#installation","text":"","title":"Installation"},{"location":"installation/#setup","text":"Clone the chesslablab/website repo into your projects folder. Then cd the website directory and install the Composer dependencies: composer install Set up the browser environment variables: cp assets/env.example.js assets/env.js Clear the cache: php bin/console cache:clear Download the assets: php bin/console importmap:install Compile the assets: php bin/console asset-map:compile Set up file permissions for the var/cache folder: sudo chmod 775 -R var/cache sudo chown $USER:www-data -R var/cache Set up file permissions for the var/log folder: sudo chmod 775 -R var/cache sudo chown $USER:www-data -R var/log","title":"Setup"},{"location":"installation/#run-on-a-docker-container","text":"First things first, make sure to have created the fullchain.pem and privkey.pem files into the docker/nginx/ssl folder.","title":"Run on a Docker Container"},{"location":"installation/#development","text":"Run the app on port 9443 . docker compose -f docker-compose.dev.yml up -d","title":"Development"},{"location":"installation/#production","text":"Run the app on port 443 . docker compose -f docker-compose.prod.yml up -d","title":"Production"},{"location":"ssl-certificate-setup/","text":"SSL Certificate Setup Some familiarity with Public Key Infrastructure (PKI) is recommended in order to follow this section. The first thing you need to understand about setting up a ChesslaBlab website is that you have to create an SSL certificate to secure four different domain names at once. chesslablab.org www.chesslablab.org api.chesslablab.org async.chesslablab.org The first two, chesslablab.org and www.chesslablab.org , will point to the website . The api.chesslablab.org domain name will point to the REST-like API and async.chesslablab.org to the asynchronous chess server . Before the Certificate Authority (CA) can issue the SSL certificate, a validation process is required to verify that it can be sent to the Certificate Signing Request (CSR) requester. This is typically achieved through one of the following methods. Email Validation \u2014 a validation email is sent to the certificate requester. HTTP Validation \u2014 the certificate requester is asked to upload a validation file at their host. DNS Validation \u2014 the certificate requester sets up a CNAME record in the domain's DNS zone for further validation. In this example, it is assumed that Certbot is run to automatically get a free HTTPS certificate. The ChesslaBlab website is running on an Ubuntu server and the certificate is validated using DNS validation as it is described next. sudo certbot certonly --standalone Saving debug log to /var/log/letsencrypt/letsencrypt.log Please enter the domain name(s) you would like on your certificate (comma and/or space separated) (Enter 'c' to cancel): chesslablab.org www.chesslablab.org api.chesslablab.org async.chesslablab.org Requesting a certificate for chesslablab.org and 3 more domains Successfully received certificate. Certificate is saved at: /etc/letsencrypt/live/chesslablab.org-0001/fullchain.pem Key is saved at: /etc/letsencrypt/live/chesslablab.org-0001/privkey.pem This certificate expires on 2024-04-23. These files will be updated when the certificate renews. Certbot has set up a scheduled task to automatically renew this certificate in the background. - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - If you like Certbot, please consider supporting our work by: * Donating to ISRG / Let's Encrypt: https://letsencrypt.org/donate * Donating to EFF: https://eff.org/donate-le - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - The command above generated two files, fullchain.pem and privkey.pem , that then were installed in the repos mentioned above: chesslablab/website chesslablab/chess-api chesslablab/chess-server It is worth saying that for this to function properly, Certbot's documentation recommends to have a working web site that can already be accessed using HTTP on port 80. Self-Signed Wildcard SSL Certificate with OpenSSL If issuing a wildcard certificate with DNS validation sounds too complicated to you, OpenSSL might be an alternate solution for the development environment. You may want to create a self-signed multi-domain SSL certificate using OpenSSL. openssl genrsa -aes256 -passout pass:foobar -out chesslablab.org.pem 2048 openssl req -passin pass:foobar -new -sha256 -key chesslablab.org.pem -subj \"/C=US/ST=CA/O=ChesslaBlab, Inc./CN=chesslablab.org\" -reqexts SAN -config <(cat /etc/ssl/openssl.cnf <(printf \"[SAN]\\nsubjectAltName=DNS:*.mydomain.org\")) -out chesslablab.org.csr openssl x509 -passin pass:foobar -req -days 365 -in chesslablab.org.csr -signkey chesslablab.org.pem -out chesslablab.org.crt openssl rsa -passin pass:foobar -in chesslablab.org.pem -out chesslablab.org.key The command above will generate four files: chesslablab.org.crt chesslablab.org.csr chesslablab.org.key chesslablab.org.pem Then, chesslablab.org.crt and chesslablab.org.key must be renamed in order to match both the certificate and the key filename created by Certbot. As noted before, it is assumed that Certbot is used to automatically generate the HTTPS certificate so all repositories are configured to read these two files on startup. mv chesslablab.org.crt fullchain.pem mv chesslablab.org.key privkey.pem With the pieces of the puzzle in place, which is to say, the web server, the REST-like API and the asynchronous chess server, it is of vital importance to add the chess server's self-signed certificate as trusted to your browser. Figure 1 . Make the browser trust the chess server's self-signed certificate. If skipping this step, the web browser won't be able to connect to the chess server. The latter will complain with an SSL handshake error. SSL handshake error: stream_socket_enable_crypto(): SSL operation failed with code 1. OpenSSL Error messages: error:14094416:SSL routines:ssl3_read_bytes:sslv3 alert certificate unknown And the web browser will throw an error accordingly. WebSocket connection to 'wss://async.chesslablab.org:8443/' failed Figure 2 . WebSocket connection to 'wss://async.chesslablab.org:8443/' failed. The exact same thing goes for the REST-like API: Its self-signed certificate needs to be added as trusted to your browser. Figure 3 . Make the browser trust the API's self-signed certificate. If skipping this step, the web browser won't be able to connect to the chess API. The latter will complain with an ERR_CERT_AUTHORITY_INVALID error. GET https://api.chesslablab.org/v1/annotations/games net::ERR_CERT_AUTHORITY_INVALID Figure 4 . The browser doesn't recognize the API's certificate. Conclusion In order to run a ChesslaBlab website, a wildcard SSL certificate needs to be issued and installed in the following repos: chesslablab/website chesslablab/chess-api chesslablab/chess-server Certbot is run to automatically get a free HTTPS certificate using DNS validation. If issuing a wildcard certificate with DNS validation sounds too complicated to you, OpenSSL might be an alternate solution for the development environment.","title":"SSL Certificate Setup"},{"location":"ssl-certificate-setup/#ssl-certificate-setup","text":"Some familiarity with Public Key Infrastructure (PKI) is recommended in order to follow this section. The first thing you need to understand about setting up a ChesslaBlab website is that you have to create an SSL certificate to secure four different domain names at once. chesslablab.org www.chesslablab.org api.chesslablab.org async.chesslablab.org The first two, chesslablab.org and www.chesslablab.org , will point to the website . The api.chesslablab.org domain name will point to the REST-like API and async.chesslablab.org to the asynchronous chess server . Before the Certificate Authority (CA) can issue the SSL certificate, a validation process is required to verify that it can be sent to the Certificate Signing Request (CSR) requester. This is typically achieved through one of the following methods. Email Validation \u2014 a validation email is sent to the certificate requester. HTTP Validation \u2014 the certificate requester is asked to upload a validation file at their host. DNS Validation \u2014 the certificate requester sets up a CNAME record in the domain's DNS zone for further validation. In this example, it is assumed that Certbot is run to automatically get a free HTTPS certificate. The ChesslaBlab website is running on an Ubuntu server and the certificate is validated using DNS validation as it is described next. sudo certbot certonly --standalone Saving debug log to /var/log/letsencrypt/letsencrypt.log Please enter the domain name(s) you would like on your certificate (comma and/or space separated) (Enter 'c' to cancel): chesslablab.org www.chesslablab.org api.chesslablab.org async.chesslablab.org Requesting a certificate for chesslablab.org and 3 more domains Successfully received certificate. Certificate is saved at: /etc/letsencrypt/live/chesslablab.org-0001/fullchain.pem Key is saved at: /etc/letsencrypt/live/chesslablab.org-0001/privkey.pem This certificate expires on 2024-04-23. These files will be updated when the certificate renews. Certbot has set up a scheduled task to automatically renew this certificate in the background. - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - If you like Certbot, please consider supporting our work by: * Donating to ISRG / Let's Encrypt: https://letsencrypt.org/donate * Donating to EFF: https://eff.org/donate-le - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - The command above generated two files, fullchain.pem and privkey.pem , that then were installed in the repos mentioned above: chesslablab/website chesslablab/chess-api chesslablab/chess-server It is worth saying that for this to function properly, Certbot's documentation recommends to have a working web site that can already be accessed using HTTP on port 80.","title":"SSL Certificate Setup"},{"location":"ssl-certificate-setup/#self-signed-wildcard-ssl-certificate-with-openssl","text":"If issuing a wildcard certificate with DNS validation sounds too complicated to you, OpenSSL might be an alternate solution for the development environment. You may want to create a self-signed multi-domain SSL certificate using OpenSSL. openssl genrsa -aes256 -passout pass:foobar -out chesslablab.org.pem 2048 openssl req -passin pass:foobar -new -sha256 -key chesslablab.org.pem -subj \"/C=US/ST=CA/O=ChesslaBlab, Inc./CN=chesslablab.org\" -reqexts SAN -config <(cat /etc/ssl/openssl.cnf <(printf \"[SAN]\\nsubjectAltName=DNS:*.mydomain.org\")) -out chesslablab.org.csr openssl x509 -passin pass:foobar -req -days 365 -in chesslablab.org.csr -signkey chesslablab.org.pem -out chesslablab.org.crt openssl rsa -passin pass:foobar -in chesslablab.org.pem -out chesslablab.org.key The command above will generate four files: chesslablab.org.crt chesslablab.org.csr chesslablab.org.key chesslablab.org.pem Then, chesslablab.org.crt and chesslablab.org.key must be renamed in order to match both the certificate and the key filename created by Certbot. As noted before, it is assumed that Certbot is used to automatically generate the HTTPS certificate so all repositories are configured to read these two files on startup. mv chesslablab.org.crt fullchain.pem mv chesslablab.org.key privkey.pem With the pieces of the puzzle in place, which is to say, the web server, the REST-like API and the asynchronous chess server, it is of vital importance to add the chess server's self-signed certificate as trusted to your browser. Figure 1 . Make the browser trust the chess server's self-signed certificate. If skipping this step, the web browser won't be able to connect to the chess server. The latter will complain with an SSL handshake error. SSL handshake error: stream_socket_enable_crypto(): SSL operation failed with code 1. OpenSSL Error messages: error:14094416:SSL routines:ssl3_read_bytes:sslv3 alert certificate unknown And the web browser will throw an error accordingly. WebSocket connection to 'wss://async.chesslablab.org:8443/' failed Figure 2 . WebSocket connection to 'wss://async.chesslablab.org:8443/' failed. The exact same thing goes for the REST-like API: Its self-signed certificate needs to be added as trusted to your browser. Figure 3 . Make the browser trust the API's self-signed certificate. If skipping this step, the web browser won't be able to connect to the chess API. The latter will complain with an ERR_CERT_AUTHORITY_INVALID error. GET https://api.chesslablab.org/v1/annotations/games net::ERR_CERT_AUTHORITY_INVALID Figure 4 . The browser doesn't recognize the API's certificate.","title":"Self-Signed Wildcard SSL Certificate with OpenSSL"},{"location":"ssl-certificate-setup/#conclusion","text":"In order to run a ChesslaBlab website, a wildcard SSL certificate needs to be issued and installed in the following repos: chesslablab/website chesslablab/chess-api chesslablab/chess-server Certbot is run to automatically get a free HTTPS certificate using DNS validation. If issuing a wildcard certificate with DNS validation sounds too complicated to you, OpenSSL might be an alternate solution for the development environment.","title":"Conclusion"},{"location":"website-architecture/","text":"Website Architecture Some familiarity with JavaScript modules as well as with Symfony's Asset Mapper component is recommended in order to follow this section. The ChesslaBlab website is a multi-page application (MPA) that is not adhering to the MVC architectural pattern. The controller actions are basically sending an HTML document to the browser on each request with the business logic being split between the chess server and the chess API. In this website architecture in particular, there is no model layer (M) and as a result the Controller layer (C) remains quite basic as in the following example. The main reason behind a multi-page architecture like this one as opposed to a single-page architecture is that we want the pages to be indexed by web crawlers. <?php namespace App\\Controller\\Pages\\Play; use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController; use Symfony\\Component\\HttpFoundation\\Response; class ComputerController extends AbstractController { public function index(): Response { return $this->render('pages/play/computer/index.html.twig'); } } As a rule of thumb, there is a .twig.html file and a .js file associated to each controller action. So the structure of the App\\Controller\\Pages namespace is mirroring the structure of both the templates/pages folder and the assets/js/pages folder. src/Controller/Pages/Play/ComputerController.php templates/pages/play/computer/index.html.twig assets/js/pages/play/computer/index.js This naming convention allows developers to reduce memorization because given one file name, the name of the remaining two can be inferred. Each page's JavaScript file is then set up as an entrypoint in the importmap.php config file. The main point of the entrypoint script is to update the DOM on user interaction and data change.","title":"Website Architecture"},{"location":"website-architecture/#website-architecture","text":"Some familiarity with JavaScript modules as well as with Symfony's Asset Mapper component is recommended in order to follow this section. The ChesslaBlab website is a multi-page application (MPA) that is not adhering to the MVC architectural pattern. The controller actions are basically sending an HTML document to the browser on each request with the business logic being split between the chess server and the chess API. In this website architecture in particular, there is no model layer (M) and as a result the Controller layer (C) remains quite basic as in the following example. The main reason behind a multi-page architecture like this one as opposed to a single-page architecture is that we want the pages to be indexed by web crawlers. <?php namespace App\\Controller\\Pages\\Play; use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController; use Symfony\\Component\\HttpFoundation\\Response; class ComputerController extends AbstractController { public function index(): Response { return $this->render('pages/play/computer/index.html.twig'); } } As a rule of thumb, there is a .twig.html file and a .js file associated to each controller action. So the structure of the App\\Controller\\Pages namespace is mirroring the structure of both the templates/pages folder and the assets/js/pages folder. src/Controller/Pages/Play/ComputerController.php templates/pages/play/computer/index.html.twig assets/js/pages/play/computer/index.js This naming convention allows developers to reduce memorization because given one file name, the name of the remaining two can be inferred. Each page's JavaScript file is then set up as an entrypoint in the importmap.php config file. The main point of the entrypoint script is to update the DOM on user interaction and data change.","title":"Website Architecture"},{"location":"websocket-integration/","text":"WebSocket Integration The ChesslaBlab website is integrated with PHP Chess Server , an asynchronous WebSocket server that provides functionality to play chess online over a WebSocket connection. Similar to the PHP Chess API , it can be hosted on a custom domain. However, while the API endpoints may take few seconds to execute \u2014 for example, a file download or a database query \u2014 the event-driven, non-blocking architecture of the chess server allows to handle multiple concurrent connections in an efficient way. The chess commands are intended to run very quickly almost in real-time. As described in the docs , four different game modes are provided. Mode Description fen Allows to continue playing a game from a specific position. san Allows to continue playing an annotated game from the starting position. play Allows to play chess online with other players. stockfish Allows to play chess against the computer. The WebSocket ESM modules are implemented based on this separation of concerns and abstraction: assets/js/FenWebSocket.js assets/js/SanWebSocket.js assets/js/PlayWebSocket.js assets/js/StockfishWebSocket.js Let's say you wanted to study a particular chess opening, then a chess game in SAN mode is to be started. Figure 1 . Click on Openings > ECO Code and select \"D77 Neo-Gr\u00fcnfeld Defense: Classical Variation, Modern Defense\" Command: /start classical san \"{\\\"movetext\\\":\\\"1.d4 Nf6 2.Nf3 g6 3.g3 Bg7 4.Bg2 O-O 5.O-O d5 6.c4 dxc4\\\"}\" Response: { \"variant\": \"classical\", \"mode\": \"san\", \"turn\": \"w\", \"movetext\": \"1.d4 Nf6 2.Nf3 g6 3.g3 Bg7 4.Bg2 O-O 5.O-O d5 6.c4 dxc4\", \"fen\": [ \"rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq -\", \"rnbqkbnr/pppppppp/8/8/3P4/8/PPP1PPPP/RNBQKBNR b KQkq d3\", \"rnbqkb1r/pppppppp/5n2/8/3P4/8/PPP1PPPP/RNBQKBNR w KQkq -\", \"rnbqkb1r/pppppppp/5n2/8/3P4/5N2/PPP1PPPP/RNBQKB1R b KQkq -\", \"rnbqkb1r/pppppp1p/5np1/8/3P4/5N2/PPP1PPPP/RNBQKB1R w KQkq -\", \"rnbqkb1r/pppppp1p/5np1/8/3P4/5NP1/PPP1PP1P/RNBQKB1R b KQkq -\", \"rnbqk2r/ppppppbp/5np1/8/3P4/5NP1/PPP1PP1P/RNBQKB1R w KQkq -\", \"rnbqk2r/ppppppbp/5np1/8/3P4/5NP1/PPP1PPBP/RNBQK2R b KQkq -\", \"rnbq1rk1/ppppppbp/5np1/8/3P4/5NP1/PPP1PPBP/RNBQK2R w KQ -\", \"rnbq1rk1/ppppppbp/5np1/8/3P4/5NP1/PPP1PPBP/RNBQ1RK1 b - -\", \"rnbq1rk1/ppp1ppbp/5np1/3p4/3P4/5NP1/PPP1PPBP/RNBQ1RK1 w - d6\", \"rnbq1rk1/ppp1ppbp/5np1/3p4/2PP4/5NP1/PP2PPBP/RNBQ1RK1 b - c3\", \"rnbq1rk1/ppp1ppbp/5np1/8/2pP4/5NP1/PP2PPBP/RNBQ1RK1 w - -\" ] } The JavaScript code for this example can be found in the assets/js/pages/openings/eco_code/index.js file. import { openingsEcoCodeModal } from './OpeningsEcoCodeModal.js'; import { sanWebSocket } from '../../../SanWebSocket.js'; await sanWebSocket.connect(); sessionStorage.clear(); openingsEcoCodeModal.props.modal.show(); Remember, the structure of the App\\Controller\\Pages namespace is mirroring the structure of both the templates/pages folder and the assets/js/pages folder. As a rule of thumb, there is a .twig.html file and a .js file associated to each controller action. This naming convention allows developers to reduce memorization because given one file name, the name of the remaining two can be inferred. src/Controller/Pages/Openings/EcoCodeController.php templates/pages/openings/eco_code/index.html.twig assets/js/pages/openings/eco_code/index.js","title":"WebSocket Integration"},{"location":"websocket-integration/#websocket-integration","text":"The ChesslaBlab website is integrated with PHP Chess Server , an asynchronous WebSocket server that provides functionality to play chess online over a WebSocket connection. Similar to the PHP Chess API , it can be hosted on a custom domain. However, while the API endpoints may take few seconds to execute \u2014 for example, a file download or a database query \u2014 the event-driven, non-blocking architecture of the chess server allows to handle multiple concurrent connections in an efficient way. The chess commands are intended to run very quickly almost in real-time. As described in the docs , four different game modes are provided. Mode Description fen Allows to continue playing a game from a specific position. san Allows to continue playing an annotated game from the starting position. play Allows to play chess online with other players. stockfish Allows to play chess against the computer. The WebSocket ESM modules are implemented based on this separation of concerns and abstraction: assets/js/FenWebSocket.js assets/js/SanWebSocket.js assets/js/PlayWebSocket.js assets/js/StockfishWebSocket.js Let's say you wanted to study a particular chess opening, then a chess game in SAN mode is to be started. Figure 1 . Click on Openings > ECO Code and select \"D77 Neo-Gr\u00fcnfeld Defense: Classical Variation, Modern Defense\" Command: /start classical san \"{\\\"movetext\\\":\\\"1.d4 Nf6 2.Nf3 g6 3.g3 Bg7 4.Bg2 O-O 5.O-O d5 6.c4 dxc4\\\"}\" Response: { \"variant\": \"classical\", \"mode\": \"san\", \"turn\": \"w\", \"movetext\": \"1.d4 Nf6 2.Nf3 g6 3.g3 Bg7 4.Bg2 O-O 5.O-O d5 6.c4 dxc4\", \"fen\": [ \"rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq -\", \"rnbqkbnr/pppppppp/8/8/3P4/8/PPP1PPPP/RNBQKBNR b KQkq d3\", \"rnbqkb1r/pppppppp/5n2/8/3P4/8/PPP1PPPP/RNBQKBNR w KQkq -\", \"rnbqkb1r/pppppppp/5n2/8/3P4/5N2/PPP1PPPP/RNBQKB1R b KQkq -\", \"rnbqkb1r/pppppp1p/5np1/8/3P4/5N2/PPP1PPPP/RNBQKB1R w KQkq -\", \"rnbqkb1r/pppppp1p/5np1/8/3P4/5NP1/PPP1PP1P/RNBQKB1R b KQkq -\", \"rnbqk2r/ppppppbp/5np1/8/3P4/5NP1/PPP1PP1P/RNBQKB1R w KQkq -\", \"rnbqk2r/ppppppbp/5np1/8/3P4/5NP1/PPP1PPBP/RNBQK2R b KQkq -\", \"rnbq1rk1/ppppppbp/5np1/8/3P4/5NP1/PPP1PPBP/RNBQK2R w KQ -\", \"rnbq1rk1/ppppppbp/5np1/8/3P4/5NP1/PPP1PPBP/RNBQ1RK1 b - -\", \"rnbq1rk1/ppp1ppbp/5np1/3p4/3P4/5NP1/PPP1PPBP/RNBQ1RK1 w - d6\", \"rnbq1rk1/ppp1ppbp/5np1/3p4/2PP4/5NP1/PP2PPBP/RNBQ1RK1 b - c3\", \"rnbq1rk1/ppp1ppbp/5np1/8/2pP4/5NP1/PP2PPBP/RNBQ1RK1 w - -\" ] } The JavaScript code for this example can be found in the assets/js/pages/openings/eco_code/index.js file. import { openingsEcoCodeModal } from './OpeningsEcoCodeModal.js'; import { sanWebSocket } from '../../../SanWebSocket.js'; await sanWebSocket.connect(); sessionStorage.clear(); openingsEcoCodeModal.props.modal.show(); Remember, the structure of the App\\Controller\\Pages namespace is mirroring the structure of both the templates/pages folder and the assets/js/pages folder. As a rule of thumb, there is a .twig.html file and a .js file associated to each controller action. This naming convention allows developers to reduce memorization because given one file name, the name of the remaining two can be inferred. src/Controller/Pages/Openings/EcoCodeController.php templates/pages/openings/eco_code/index.html.twig assets/js/pages/openings/eco_code/index.js","title":"WebSocket Integration"}]}